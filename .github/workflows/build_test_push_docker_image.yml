name: Build, Test and Release Docker Images

on:
  push:
    branches: [ main ]
    paths:
      - 'docker_image_resources/**'
      - '.github/workflows/build_docker_image.yml'
      - '**/*.go'
      - 'go.mod'
      - 'go.sum'
  workflow_dispatch:
  workflow_call:

env:
  REGISTRY: ${{secrets.REGISTRY}}
  STAGING_REPOSITORY: ${{secrets.STAGING_REPOSITORY}}
  AWS_REGION: us-east-1

jobs:
  build-and-push:
    name: Build Docker Images
    permissions:
      contents: read
      packages: write
      id-token: write   # This is required for requesting the JWT for AWS authentication
    strategy:
      matrix:
        include:
          - os: ubuntu-24.04
            platform: amd64
          - os: ubuntu-24.04-arm
            platform: arm64
    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: ${{ secrets.GH_ACCESS_ROLE }} 
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker_image_resources/Dockerfile
          platforms: linux/${{ matrix.platform }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.STAGING_REPOSITORY }}:${{ github.sha }}-${{ matrix.platform }}
          provenance: false

  test-and-scan:
    name: Test and Scan Docker Images
    needs: build-and-push
    permissions:
      contents: read
      id-token: write   # This is required for requesting the JWT for AWS authentication
    strategy:
      matrix:
        include:
          - os: ubuntu-24.04
            platform: amd64
          - os: ubuntu-24.04-arm
            platform: arm64 
    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: ${{ secrets.GH_ACCESS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Set up test environment
        env:
            REPOSITORY: ${{env.STAGING_REPOSITORY}}
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.STAGING_REPOSITORY }}:${{ github.sha }}-${{matrix.platform}}

          mkdir -p docker_image_resources/tests/certs
          
          # Generate private key
          openssl genrsa -out docker_image_resources/tests/certs/private_key.pem 2048
          
          # Create CSR (Certificate Signing Request)
          openssl req -new -key docker_image_resources/tests/certs/private_key.pem \
            -out /tmp/certificate.csr \
            -subj "/CN=credential-helper-test/O=Amazon/OU=Cryptography"
          
          # Convert CSR to base64 for AWS CLI
          CSR_CONTENT=$(cat /tmp/certificate.csr | base64 -w 0)
          
          # Issue certificate using AWS Private CA
          CERTIFICATE_RESPONSE=$(aws acm-pca issue-certificate \
            --certificate-authority-arn ${{ secrets.PCA_ARN }} \
            --csr $CSR_CONTENT \
            --signing-algorithm "SHA256WITHRSA" \
            --validity Value=1,Type=DAYS \
            --output json)
          
          CERTIFICATE_ARN=$(echo $CERTIFICATE_RESPONSE | jq -r '.CertificateArn')

          aws acm-pca wait certificate-issued --certificate-authority-arn ${{ secrets.PCA_ARN }} --certificate-arn $CERTIFICATE_ARN
          
          # Get the issued certificate
          CERTIFICATE=$(aws acm-pca get-certificate \
            --certificate-authority-arn ${{ secrets.PCA_ARN }} \
            --certificate-arn $CERTIFICATE_ARN \
            --output json)
          
          # Write certificate directly to file
          jq -r '.Certificate' <<< "$CERTIFICATE" > docker_image_resources/tests/certs/certificate.pem
          
      - name: Test the ${{matrix.platform}} Docker Image
        env:
          TRUST_ANCHOR_ARN : ${{ secrets.TRUST_ANCHOR_ARN }}
          PROFILE_ARN: ${{ secrets.PROFILE_ARN }}
          ROLE_ARN : ${{ secrets.TESTING_ROLE_ARN }}
          VERSION : ${{ github.sha }}-${{matrix.platform}}
        run: |
          # Make scripts executable
          chmod +x docker_image_resources/tests/*.sh
          chmod +x docker_image_resources/tests/scripts/*.sh
          
          # Run basic version test
          echo "Testing version command:"
          docker run --rm ${{ env.REGISTRY }}/${{ env.STAGING_REPOSITORY }}:${{ github.sha }}-${{matrix.platform}} version

          # Set up KinD and run tests
          cd docker_image_resources
          ./tests/run-tests.sh || exit 1
          
      - name: Install Trivy Image Scanner 
        uses: aquasecurity/setup-trivy@v0.2.0
        with:
          cache: true
          version: v0.63.0

      - name: Scan Docker image with Trivy
        run: |
          IMAGE_REFERENCE="${{ env.REGISTRY }}/${{ env.STAGING_REPOSITORY }}:${{ github.sha }}-${{matrix.platform}}"
          
          # Run Trivy scan and capture JSON output directly
          echo "Generating JSON scan results..."
          SCAN_OUTPUT=$(trivy image --ignorefile docker_image_resources/tests/.trivyignore --no-progress --severity CRITICAL,HIGH,MEDIUM,LOW $IMAGE_REFERENCE --format json)

          # Display scan result directly
          echo $SCAN_OUTPUT

          # Initialize counts with default values
          CRITICAL_COUNT=0
          HIGH_COUNT=0
          MEDIUM_COUNT=0
          LOW_COUNT=0
          
          # Extract vulnerability counts by severity with error handling
          if [ -n "$SCAN_OUTPUT" ]; then
            # Check if we have vulnerabilities in the results
            if echo "$SCAN_OUTPUT" | jq -e '.Results[] | select(.Vulnerabilities != null)' > /dev/null; then
              CRITICAL_COUNT=$(echo "$SCAN_OUTPUT" | jq '[.Results[] | select(.Vulnerabilities != null) | .Vulnerabilities | map(select(.Severity == "CRITICAL")) | length] | add // 0' 2>/dev/null || echo 0)
              HIGH_COUNT=$(echo "$SCAN_OUTPUT" | jq '[.Results[] | select(.Vulnerabilities != null) | .Vulnerabilities | map(select(.Severity == "HIGH")) | length] | add // 0' 2>/dev/null || echo 0)
              MEDIUM_COUNT=$(echo "$SCAN_OUTPUT" | jq '[.Results[] | select(.Vulnerabilities != null) | .Vulnerabilities | map(select(.Severity == "MEDIUM")) | length] | add // 0' 2>/dev/null || echo 0)
              LOW_COUNT=$(echo "$SCAN_OUTPUT" | jq '[.Results[] | select(.Vulnerabilities != null) | .Vulnerabilities | map(select(.Severity == "LOW")) | length] | add // 0' 2>/dev/null || echo 0)
            else
              echo "No vulnerabilities found in scan results."
            fi
          else
            echo "Warning: Empty scan output from Trivy."
          fi
          
          # Ensure counts are valid integers
          CRITICAL_COUNT=${CRITICAL_COUNT:-0}
          HIGH_COUNT=${HIGH_COUNT:-0}
          MEDIUM_COUNT=${MEDIUM_COUNT:-0}
          LOW_COUNT=${LOW_COUNT:-0}
          
          # Print vulnerability counts
          echo "Vulnerability counts:"
          echo "Critical: $CRITICAL_COUNT"
          echo "High: $HIGH_COUNT"
          echo "Medium: $MEDIUM_COUNT"
          echo "Low: $LOW_COUNT"
          
          # Check if vulnerability thresholds are exceeded
          if [ "$CRITICAL_COUNT" -gt 0 ] || [ "$HIGH_COUNT" -gt 0 ] || [ "$MEDIUM_COUNT" -ge 8 ] || [ "$LOW_COUNT" -ge 15 ]; then
            echo "::error::Vulnerability thresholds exceeded!"
            echo "Threshold criteria:"
            echo "- Critical: 0 (found: $CRITICAL_COUNT)"
            echo "- High: 0 (found: $HIGH_COUNT)"
            echo "- Medium: <8 (found: $MEDIUM_COUNT)"
            echo "- Low: <15 (found: $LOW_COUNT)"
            exit 1
          else
            echo "Vulnerability scan passed. All thresholds are within acceptable limits."
          fi
  publish-images-to-ecr:
    name: Publish built images to ECR 
    needs: test-and-scan
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      id-token: write   # This is required for requesting the JWT for AWS authentication
    env:
      PUBLIC_REPOSITORY: ${{secrets.PUBLIC_REPOSITORY}}
      AWS_SIGNER_PLUGIN_LINK: https://d2hvyiie56hcat.cloudfront.net/linux/amd64/plugin/latest/notation-aws-signer-plugin.zip
      AWS_SIGNER_PLUGIN_FILENAME: notation-aws-signer-plugin.zip
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: ${{ secrets.GH_ACCESS_ROLE }} 
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Tag Images and Push to ECR
        id: tag_and_push  
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.STAGING_REPOSITORY }}:${{ github.sha }}-amd64
          #docker pull ${{ env.REGISTRY }}/${{ env.STAGING_REPOSITORY }}:${{ github.sha }}-arm64
          # extract version from executable
          VERSION=$(docker run --rm ${{ env.REGISTRY }}/${{ env.STAGING_REPOSITORY }}:${{ github.sha }}-amd64 version)
          TIMESTAMP=$(date +%Y.%m.%d.%H.%M)
          docker tag ${{ env.REGISTRY }}/${{ env.STAGING_REPOSITORY }}:${{ github.sha }}-amd64 ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}:$VERSION-amd64-$TIMESTAMP
          docker tag ${{ env.REGISTRY }}/${{ env.STAGING_REPOSITORY }}:${{ github.sha }}-amd64 ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}:latest-amd64
          docker push ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}:$VERSION-amd64-$TIMESTAMP
          AMD64_IMAGE_SHA=$(docker push ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}:latest-amd64 | grep digest | cut -d' ' -f3 )
          echo "amd64_image_sha=$AMD64_IMAGE_SHA" >> "$GITHUB_OUTPUT"
          #docker tag ${{ env.REGISTRY }}/${{ env.STAGING_REPOSITORY }}:${{ github.sha }}-arm64 ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}:$VERSION-arm64-$TIMESTAMP
          #docker tag ${{ env.REGISTRY }}/${{ env.STAGING_REPOSITORY }}:${{ github.sha }}-arm64 ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}:latest-arm64
          #docker push ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}:$VERSION-arm64-$TIMESTAMP
          #ARM64_IMAGE_SHA=$(docker push ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}:latest-arm64 | grep digest | cut -d' ' -f3 )
          #echo "arm64_image_sha=$ARM64_IMAGE_SHA" >> "$GITHUB_OUTPUT"
          docker manifest create ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}:latest \
            ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}@$AMD64_IMAGE_SHA \
          # ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}@$ARM64_IMAGE_SHA 
          echo "manifest_sha=$(docker manifest push ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}:latest)" >> "$GITHUB_OUTPUT"

      - name: setup Notation CLI
        uses: notaryproject/notation-action/setup@v1

      - name: Retrieve AWS Signer Checksum value 
        id: checksum
        run: |
          curl -LO ${{ env.AWS_SIGNER_PLUGIN_LINK}}
          echo "signer_sha=$(sha256sum ${{env.AWS_SIGNER_PLUGIN_FILENAME}} | cut -f1 -d' ')" >> "$GITHUB_OUTPUT"

      - name: Sign the amd64 image with notation 
        uses: notaryproject/notation-action/sign@v1
        with:
          plugin_name: com.amazonaws.signer.notation.plugin
          plugin_url: https://d2hvyiie56hcat.cloudfront.net/linux/amd64/plugin/latest/notation-aws-signer-plugin.zip 
          plugin_checksum: ${{steps.checksum.outputs.signer_sha}} # Required in order to use the AWS signer plugin
          key_id: ${{secrets.SIGNING_PROFILE}}
          target_artifact_reference: |-
            ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}@${{steps.tag_and_push.outputs.manifest_sha}}
            ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}@${{steps.tag_and_push.outputs.amd64_image_sha}}
            ${{ env.REGISTRY }}/${{ env.PUBLIC_REPOSITORY }}@${{steps.tag_and_push.outputs.arm64_image_sha}}